/*
 * @lc app=leetcode.cn id=123 lang=cpp
 *
 * [123] 买卖股票的最佳时机 III
 */
#include <vector>
using namespace std;
// @lc code=start

// 目前写dp经常遇到的问题就是，覆盖情况不完全——原因是，对状态的定义错误，不完整、不科学
// 为什么要区分成持股、未持股
// 现实中买股票，有买入、持有、卖出
// 但是截止到交易结束，本质只有两个状态：持有、未持有
// 未持有可以是今天卖的，也可以是之前卖的，更可以是从来没有买过
// 然而，抽象到状态机，这样细分是不合理的
// 所以，要抽象成两个状态

// 定义d[i]表示第i天的状态，分类：是否持股，卖出几次
// 最终返回最后一天、未持股、卖出两次的结果

// 要注意的点多、写起来麻烦、时空效率低

// 股票问题，抽象成：是否持股、卖出几次，迭代是根据历史情况获得当前值

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(3)));  // 3层、2层、1层
        // 1.定义初始值
        // 第0天只有持有、不持有两种情况(买、不买)
        dp[0][0][0]=0, dp[0][1][0]=-prices[0];
        // 其他初始值 - 为了避免溢出、避免做减法的时候选错值
        dp[0][0][1]=INT_MIN/2, dp[0][0][2]=INT_MIN/2;
        dp[0][1][1]=INT_MIN/2, dp[0][1][2]=INT_MIN/2;
        for(int i=1; i<n; i++){
            // 不持有，卖出0次
            dp[i][0][0] = 0;
            // 不持有，卖出1次-可能是今天卖的也可能是以前卖的(昨天的持有卖出0次+今天的价格、昨天的不持有卖出一次)
            dp[i][0][1] = max(dp[i-1][1][0]+prices[i], dp[i-1][0][1]);
            // 不持有，卖出2次-今天卖的、以前卖的(昨天的持有卖1次+今天的价格、昨天的不持有卖2次)
            dp[i][0][2] = max(dp[i-1][1][1]+prices[i], dp[i-1][0][2]);
            // 持有，卖出0次 - 今天买的、以前买的
            dp[i][1][0] = max(dp[i-1][0][0]-prices[i], dp[i-1][1][0]); 
            // 持有，卖出1次 - 今天买的、以前买的
            dp[i][1][1] = max(dp[i-1][0][1]-prices[i], dp[i-1][1][1]);
            // 持有，卖出2次(这种情况没有意义，但是不做设置，后期迭代就可能选错值)
            dp[i][1][2] = INT_MIN;
        }
        return max(0, max(dp[n-1][0][1], dp[n-1][0][2]));
        
    }
};
// @lc code=end

